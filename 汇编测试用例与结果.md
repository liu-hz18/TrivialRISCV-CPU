**计组验收**

实现的功能：

​	**多周期CPU， 支持基础及扩展指令、各种异常、页表、TLB、页表异常**

`make EN_INT=y EN_PAGING=y EN_UART16550=n`

180板子

**性能测试**

`UTEST_1PTB`: ~73s

```assembly
UTEST_1PTB:
    li t0, 0x04000000
.LC0:
    addi t0, t0, -1
    ori t1, zero, 0
    ori t2, zero, 1
    ori t3, zero, 2
    bne t0, zero, .LC0
    jr ra
```

`UTEST_2DCT`: ~40s

```assembly
UTEST_2DCT:
    lui t0, %hi(0x01000000)
    ori t1, zero, 1
    ori t2, zero, 2
    ori t3, zero, 3
.LC1:
    xor t2, t2, t1
    xor t1, t1, t2
    xor t2, t2, t1
    xor t3, t3, t2
    xor t2, t2, t3
    xor t3, t3, t2
    xor t1, t1, t3
    xor t3, t3, t1
    xor t1, t1, t3
    addi t0, t0, -1
    bne t0, zero, .LC1
    jr ra
```

`UTEST_3CCT`: ~60s

```assembly
UTEST_3CCT:
    lui t0, %hi(0x04000000)
.LC2_0:
    bne t0, zero, .LC2_1
    jr ra
.LC2_1:
    j .LC2_2
.LC2_2:
    addi t0, t0, -1
    j .LC2_0
    addi t0, t0, -1
```

`UTEST_4MDCT` : ~55s

```assembly
UTEST_4MDCT:
    lui a0, 0x7fc10 # virtual addr!
    addi a0, a0, 4
    lui t0, %hi(0x02000000)
.LC3:
    sw t0, 0(a0)
    lw t1, 0(a0)
    addi t1, t1, -1
    sw t1, 0(a0)
    lw t0, 0(a0)
    bne t0, zero, .LC3
    addi a0, a0, 4
    jr ra
```

`UTEST_CRYPTONIGHT` : ~3.9s

```assembly
UTEST_CRYPTONIGHT:
    li a0, 0x7FC10000 # base addr 0x80400000
    li a1, 0x200000 # 2M bytes
    li a3, 524288 # number of iterations
    li a4, 0x1FFFFC # 2M mask
    add a1, a1, a0 # end addr
    li s0, 1 # rand number
    mv a2, a0
.INIT_LOOP:
    sw s0, 0(a2)
    # xorshift lfsr
    slli s1, s0, 13
    xor s0, s0, s1
    srli s1, s0, 17
    xor s0, s0, s1
    slli s1, s0, 5
    xor s0, s0, s1
    addi a2, a2, 4
    bne a2, a1, .INIT_LOOP
    li a2, 0
    li t0, 0
.MAIN_LOOP:
    # calculate a valid addr from rand number
    and t0, s0, a4
    add t0, a0, t0
    # read from it
    lw t0, 0(t0)
    # xor with last iteration t0
    xor t0, t0, t1
    # xor rand number with current t0
    xor s0, s0, t0
    # get new rand number from xorshift lfsr
    slli s1, s0, 13
    xor s0, s0, s1
    srli s1, s0, 17
    xor s0, s0, s1
    slli s1, s0, 5
    xor s0, s0, s1
    # calculate a valid addr from new rand number
    and t1, s0, a4
    add t1, a0, t1
    # write t0 to this addr
    sw t0, 0(t1)
    # save t0 for next iteration
    mv t1, t0
    # get new rand number from xorshift lfsr
    slli s1, s0, 13
    xor s0, s0, s1
    srli s1, s0, 17
    xor s0, s0, s1
    slli s1, s0, 5
    xor s0, s0, s1
    add a2, a2, 1
    bne a2, a3, .MAIN_LOOP
    jr ra
```



**异常和页表的测试**

`kernel`中已经有`ebreak`和`mret`及相关`csr`读写指令

`ecall`的展示：使用`ecall`输出所有可见字符

```assembly
.section .text
.globl _start
_start:
    addi t0, x0, 0x20
    addi t1, x0, 0x7F
loop:
    addi t0,t0,0x1
    li s0,30
    add a0,x0,t0
    ecall
    bne t0, t1, loop
    jr ra
```

使用`ecall`输出OK

```assembly
UTEST_PUTC:
    li s0, 30
    li a0, 0x4F              # 'O'
    ecall
    li a0, 0x4B              # 'K'
    ecall
    jr ra
```

**页表的展示**

运行`T`命令

用页表版本的kernel, 运行计算fib(0)-fib(9)的程序

```assembly
.section .text
.globl _start
_start:
    ori t0, zero, 0x0        # fib(0)
    ori t1, zero, 0x1        # fib(1)
    ori t2, zero, 10         # save 10 in t2
    ori t5, zero, 0x2        # i = 2
    lui t3, 0x7fc10          # save addr in t3 0x80400
    sw t0, 0(t3)             # save fib(0) in t3
    addi t3, t3, 4           # t3 += 4
    sw t1, 0(t3)             # save fib(1) in t3
    addi t3, t3, 4           # t3 += 4
loop:
    add t4, t0, t1           # t4 = t0 + t1 (fib(n) = fib(n-1) + fib(n-2))
    sw t4, 0(t3)             # save fib(n) in t3
    addi t3, t3, 4           # t3 += 4
    addi t5, t5, 1           # i ++
    ori t0, t1, 0x0          # t0 = t1
    ori t1, t4, 0x0          # t1 = t4
    bne t5, t2, loop         # i != 10 ? loop : break
    jr ra    
```

运行`D`查看`0x80400000`位置是否正确写入40字节



**非法指令(`sltu`)异常，异常码2**

```assembly
.section .text
.globl _start
_start:
 addi a0, x0, 0x0
 addi a1, x0, 0x0
 addi a2, x0, 0x1
 addi a3, x0, 0x0
 addi t3, x0, 0x3c
 lui t4,0x7fc10
loop:
 add t1, x0, a2
 add t2, x0, a3
 add a5,x0, a2
 add a2, a2, a0
 sltu a5, a2, a5 # error!
 add a3,a1, a3
 add a3,a5, a3
 add a0,x0, t1
 add a1,x0, t2 
 add t3, t3, -1
 bne t3, x0, loop
 sw a0,(t4)
 addi t4,t4,0x4
 sw a1,(t4)
 jr ra
```



**地址不对齐异常：**

`store`地址不对齐: 异常码`6`

```assembly
 .section .text
.globl _start
_start:
 addi t1, x0, 0x1
 lui t4,0x7fc10
 addi t4, t4, 0x1
 sw t1,(t4) # error!
 ret
```

`load`地址不对齐：异常码`4`

```assembly
 .section .text
.globl _start
_start:
 addi t1, x0, 0x1
 lui t4,0x7fc10
 addi t4, t4, 0x1
 lw t1,(t4)# error!
 ret
```

取指地址不对齐：异常码`0`

```assembly
#0b0000000_00000_00000_000_00110_1100011, beq zero, zero, 2 
0x363 # error!
li s0, 30
li a0, 0x4F              # 'O'
ecall
li a0, 0x4B              # 'K'
ecall
ret
```



**地址越界相关**

`store`地址越界: 异常码`7`

```assembly
UTEST_4MDCT:
    lui a0, 0x7fc10
    lui t0, %hi(0x02000000)          # 装入32M
    addi a0, a0, -4
.LC3:
    sw t0, 0(a0)  # error!
    lw t1, 0(a0)
    addi t1, t1, -1
    sw t1, 0(a0)
    lw t0, 0(a0)
    bne t0, zero, .LC3
    addi a0, a0, 4
    jr ra
```

`load`地址越界: 异常码`5`

```assembly
UTEST_4MDCT:
    lui a0, 0x7fc10
    lui t0, %hi(0x02000000)          # 装入32M
.LC3:
    sw t0, 0(a0) 
    addi a0, a0, -4
    lw t1, 0(a0)  # error!
    addi t1, t1, -1
    sw t1, 0(a0)
    lw t0, 0(a0)
    bne t0, zero, .LC3
    addi a0, a0, 4
    jr ra
```



**页表异常相关**

`store page fault`: 以权限错误为例，向代码区写数据

```assembly
.section .text
.globl _start
_start:
 addi t1, x0, 0x1
 lui t4,0x00000   # error!, write 0x80100000
 addi t4, t4, 0x4
 sw t1,(t4)
 ret
```

`load page fault`: 因为所有虚地址均可读，应该不会出错。



**小组分工**

代码编写与调试：刘泓尊

文档与资料、测试汇编代码、小黄鸭！！：刘云昊

PPT制作：张瀚天

